---
title: 原型链继承
description: ""
publishDate: 2025-09-19
tags:
  - JavaScript
draft: false
---



JavaScript 是一种基于原型（prototype-based）的语言。与基于类的继承（class-based inheritance）不同，对象不通过类蓝图创建，而是直接从其他对象继承属性和方法。`prototype` 是实现这一核心机制的关键。

## 核心：三位一体

JavaScript 的继承模型围绕三个核心组件构建：

1.  **构造函数 (Constructor Function)**：一个普通的函数，当通过 `new` 关键字调用时，它被用作创建对象的“工厂”。例如，`function Person() {}`。

2.  **原型属性 (`.prototype`)**: 每个构造函数都拥有一个名为 `prototype` 的公共属性，该属性指向一个对象。这个对象包含了所有希望被该构造函数创建的实例所共享的属性和方法。

3.  **实例对象 (Instance Object)**：通过 `new Constructor()` 创建的对象。每个实例内部都有一个名为 `[[Prototype]]` 的内部属性（非标准但通用的访问器是 `__proto__`），该属性引用了其构造函数的 `.prototype` 对象。这是实例与共享原型之间的链接。

**关键区别**: `Constructor.prototype` 是一个存在于**构造函数上**的属性。而 `[[Prototype]]` 是一个存在于**每个实例对象上**的内部链接，它指向了前者的那个对象。`Object.getPrototypeOf(instance)` 是访问 `[[Prototype]]` 的标准方法。

## 属性查找：顺着链条往上

当访问一个对象的属性时（例如 `person1.species`），JavaScript 引擎会执行一个动态的查找过程，这被称为“原型链查找”：

1.  **实例优先**: 引擎首先检查对象实例自身是否拥有该属性（即“自有属性”或 "own property"）。如果找到，则返回其值，查找结束。
2.  **遍历链条**: 如果实例上没有找到，引擎会通过 `[[Prototype]]` 链接访问其原型对象，并在该对象上查找该属性。
3.  **继续向上**: 如果在原型对象上也未找到，查找过程会继续沿着原型对象的 `[[Prototype]]` 链接向上，逐级递归，直到 `Object.prototype`。
4.  **链条终点**: 如果在 `Object.prototype` 上也找不到，查找会到达原型链的终点（`Object.prototype.[[Prototype]]` 指向 `null`），此时引擎返回 `undefined`。

## 三种操作与它们的影响

对原型的操作可分为三类，其后果截然不同：

**修改原型对象**

这是向原型添加或修改属性的标准方法。

*   **语法**: `Person.prototype.sayHello = function() { /*...*/ };`
*   **机制**: 此操作直接在 `Person.prototype` 指向的那个共享对象上进行添加或修改。由于所有通过 `new Person()` 创建的实例的 `[[Prototype]]` 都引用了这同一个对象，所以变更会立即对所有实例生效（不论其创建于变更之前还是之后）。
*   **效果**: 全局共享。这是为类型扩展功能的推荐方式。

**实例赋值与属性遮蔽**

当对实例的继承属性进行赋值时，会发生属性遮蔽。

*   **语法**: `person1.species = "Alien";`
*   **机制**: 此赋值操作触发了 `[[Set]]` 内部方法。该方法首先检查 `person1` 自身。由于 `species` 不存在于 `person1` 的自有属性中，赋值操作会**在 `person1` 实例上创建一个新的自有属性** `species`。这个新属性会“遮蔽”或“隐藏”原型链上同名的 `species` 属性。
*   **效果**: 仅影响当前实例。`person2.species` 的访问路径不受影响，仍然会沿着原型链找到 `Person.prototype.species`。可以使用 `instance.hasOwnProperty('species')` 来验证属性是自有的还是继承的。

**重写整个 `prototype`**

这是一个破坏性操作，它用一个全新的对象替换了构造函数的 `prototype` 属性。

*   **语法**: `Person.prototype = { constructor: Person, sayHi: function() {} };`
*   **机制**: 此操作改变了 `Person.prototype` 的引用，使其指向一个全新的对象。这**切断了现有实例与新原型之间的联系**。
*   **效果**:
    *   **现有实例**: 在重写**之前**创建的实例，其 `[[Prototype]]` 仍然指向被废弃的**旧原型对象**。因此，它们无法访问新原型上的任何属性（如 `sayHi`）。
    *   **新实例**: 在重写**之后**创建的实例，其 `[[Prototype]]` 将指向这个**新原型对象**。
    *   **`constructor` 属性丢失**: 字面量对象 `{}` 的原型是 `Object.prototype`，它没有指向 `Person` 的 `constructor` 属性。因此，重写后必须显式地将 `constructor` 属性重新指回构造函数本身 (`constructor: Person`)，以维持原型链的完整性和 `instance.constructor` 的正确性。

## Object.create()实现继承
---

### **核心摘要**

`Object.create()` 是 JavaScript 中一个强大且直接的内置方法，用于创建一个新对象，并将其 `[[Prototype]]`（即 `__proto__`）显式地指向另一个对象。它提供了一种不依赖构造函数 (`constructor`) 和 `new` 关键字的、更为纯粹和灵活的原型继承实现方式。理解 `Object.create()` 是深入掌握 JavaScript 原型链和继承机制的关键。

---

### **1. 深入理解 `Object.create()` 的语法与行为**

#### **语法**

```javascript
Object.create(proto, [propertiesObject]);
```

- **`proto` (必需参数)**
  - 这是新创建对象的原型。它应该是一个对象或 `null`。
  - **关键点**：新创建的对象会继承这个 `proto` 对象上的所有属性和方法。
  - 如果传入 `null`，则新创建的对象将没有任何原型，它不继承任何东西，甚至连 `toString()`, `valueOf()` 等来自 `Object.prototype` 的方法都没有。这是一个非常“干净”的空对象。

- **`propertiesObject` (可选参数)**
  - 这是一个对象，其自身的可枚举属性（即那些不是通过原型链继承来的属性）将被添加到新创建的对象中，并指定这些属性的特性（如 `writable`, `enumerable`, `configurable`, `value` 等）。
  - 其语法与 `Object.defineProperties()` 的第二个参数相同。
  - 这个参数让我们可以在创建对象的同时，为其添加自身的、非继承的属性。

#### **基本行为示例**

让我们用一个简单的例子来拆解它的行为：

```javascript
// 1. 定义一个原型对象
const personPrototype = {
  greet() {
    console.log(`Hello, my name is ${this.name}.`);
  }
};

// 2. 使用 Object.create() 创建一个新对象，并指定其原型
const alice = Object.create(personPrototype);

// 3. 为新对象添加自身的属性
alice.name = 'Alice';

// 4. 调用方法
alice.greet(); // 输出: Hello, my name is Alice.

console.log(Object.getPrototypeOf(alice) === personPrototype); // true
console.log(alice.__proto__ === personPrototype); // true
```

---

### **2. 第二个参数 `propertiesObject` 的使用**

这个可选参数让我们可以更精细地控制新对象自身的属性。

```javascript
const vehiclePrototype = {
  start() {
    console.log(`Engine started for ${this.model}.`);
  }
};

const myCar = Object.create(vehiclePrototype, {
  // 使用属性描述符对象来定义属性
  model: {
    value: 'Tesla Model 3', // 属性的值
    writable: true,         // 是否可以修改
    enumerable: true,      // 是否可以被 for...in 或 Object.keys() 遍历
    configurable: true      // 是否可以删除或修改属性描述符
  },
  year: {
    value: 2023,
    writable: false,        // year 属性不可写
    enumerable: true,
    configurable: false
  }
});

myCar.start(); // 输出: Engine started for Tesla Model 3.
console.log(myCar.model);  // 输出: Tesla Model 3

myCar.model = 'Model S';
console.log(myCar.model);  // 输出: Model S (修改成功)

myCar.year = 2024;         // 严格模式下会报错，非严格模式下静默失败
console.log(myCar.year);   // 输出: 2023 (修改失败)
```

**`propertiesObject` vs. 创建后赋值**

-   **创建后赋值 (`obj.key = value`)**: 简单直接，但创建的属性默认是 `writable`, `enumerable`, `configurable` 的。
-   **`propertiesObject`**: 更为强大和规范，可以精确控制每个属性的特性，适合需要创建具有特定“元数据”的属性的场景，例如创建只读常量或私有属性（通过 `enumerable: false`）。

---

### **3. `Object.create()` 与传统构造函数继承的对比**

#### **对比与优势**

| 特性 | 构造函数 + `new` | `Object.create()` | `Object.create()` 的优势 |
| :--- | :--- | :--- | :--- |
| **概念纯粹性** | 混合了“构造对象”和“定义原型”两个概念。构造函数本身既是蓝图，又通过其 `prototype` 属性扮演原型角色。 | 将“对象”和“原型”完全分离。你先有一个原型对象，然后基于它创建新对象。概念更清晰，更符合原型继承的本质。 | **更纯粹、更直观**。继承关系是对象与对象之间的直接委托，而不是通过“类”的构造函数这个中间人。 |
| **灵活性** | 如果想改变一个对象的原型，操作起来比较麻烦且不常见。原型在 `new` 的一刻就基本确定了。 | 非常灵活。你可以随时定义一个原型对象，然后基于它创建任意数量的实例。甚至可以动态地组合原型。 | **灵活性更高**。非常适合“混入”（Mixin）模式或动态构建对象行为。 |
| **代码简洁性** | 对于简单的继承，代码量相当。但当需要复杂的继承链时，代码会变得复杂（如 `Parent.call(this)` 和 `Object.setPrototypeOf()`）。 | 代码往往更简洁，特别是当你不需要复杂的初始化逻辑时。 | **代码更简洁**，避免了 `constructor` 和 `this` 的绑定问题。 |
| **创建“干净”对象** | `new Object()` 或 `{}` 创建的对象，其原型链顶端总是 `Object.prototype`。 | `Object.create(null)` 可以创建一个真正没有任何原型的对象。 | **创建字典/映射的理想选择**。因为没有原型，所以不会有 `toString`, `hasOwnProperty` 等方法的干扰，`for...in` 循环也更安全。 |

---

### **4. `Object.create(null)` 的特殊用途**

这是 `Object.create()` 一个非常重要的应用场景。

```javascript
const normalObject = {};
const nullPrototypeObject = Object.create(null);

console.log(normalObject.toString); // [Function: toString]
console.log(nullPrototypeObject.toString); // undefined

console.log('toString' in normalObject); // true
console.log('toString' in nullPrototypeObject); // false

for (const key in normalObject) {
  // 可能会遍历到来自原型链的 key
  console.log(key);
}

for (const key in nullPrototypeObject) {
  // 只会遍历对象自身的 key，非常安全
  console.log(key);
}
```

**为什么这很有用？**

当你需要一个对象纯粹作为键值对的存储容器（例如，一个 `Map` 或 `Dictionary`），使用 `Object.create(null)` 是最佳实践。它可以完全避免与 `Object.prototype` 上的默认方法发生命名冲突或意外覆盖。例如，如果你存储的键恰好是 `"hasOwnProperty"`，在普通对象上就会出问题，但在无原型对象上则完全安全。

```javascript
// 危险的做法
const data = {};
data.hasOwnProperty = 'Oops, I overwrote a method!';
// data.hasOwnProperty('key') // 现在会报错！

// 安全的做法
const safeData = Object.create(null);
safeData.hasOwnProperty = 'This is just a string, no problem!';
// 因为 safeData 根本没有 hasOwnProperty 方法
```

---

### **总结**

`Object.create()` 是现代 JavaScript 中实现原型继承的基石性方法。

1.  **核心功能**：它提供了一种显式、直接的方式，让一个新对象“继承”自另一个现有对象，建立起清晰的原型委托关系。
2.  **概念优势**：它将继承从“基于类的构造函数”模式中解放出来，回归到 JavaScript “基于原型的”语言本质，使得继承模型更加纯粹和易于理解。
3.  **实践价值**：
    *   **灵活继承**：无需构造函数即可轻松实现继承，特别适合动态和组合式的编程风格。
    *   **精细控制**：通过第二个参数，可以精确地定义新对象自身属性的特性。
    *   **创建纯净对象**：`Object.create(null)` 是创建安全、无干扰的数据字典（Map）的黄金标准。

虽然 `class` 语法在 ES6 之后提供了更符合传统面向对象编程习惯的“语法糖”，但 `class` 的底层机制仍然是基于原型的。深入理解 `Object.create()`，不仅能让你掌握一种强大的编程工具，更能帮助你洞悉 JavaScript 语言继承机制的根本原理，从而写出更健壮、更灵活、更地道的代码。