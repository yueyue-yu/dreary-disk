---
title: 原型链继承
description: ""
publishDate: 2025-09-19
tags:
  - JavaScript
draft: false
---



JavaScript 是一种基于原型（prototype-based）的语言。与基于类的继承（class-based inheritance）不同，对象不通过类蓝图创建，而是直接从其他对象继承属性和方法。`prototype` 是实现这一核心机制的关键。

## 核心：三位一体

JavaScript 的继承模型围绕三个核心组件构建：

1.  **构造函数 (Constructor Function)**：一个普通的函数，当通过 `new` 关键字调用时，它被用作创建对象的“工厂”。例如，`function Person() {}`。

2.  **原型属性 (`.prototype`)**: 每个构造函数都拥有一个名为 `prototype` 的公共属性，该属性指向一个对象。这个对象包含了所有希望被该构造函数创建的实例所共享的属性和方法。

3.  **实例对象 (Instance Object)**：通过 `new Constructor()` 创建的对象。每个实例内部都有一个名为 `[[Prototype]]` 的内部属性（非标准但通用的访问器是 `__proto__`），该属性引用了其构造函数的 `.prototype` 对象。这是实例与共享原型之间的链接。

**关键区别**: `Constructor.prototype` 是一个存在于**构造函数上**的属性。而 `[[Prototype]]` 是一个存在于**每个实例对象上**的内部链接，它指向了前者的那个对象。`Object.getPrototypeOf(instance)` 是访问 `[[Prototype]]` 的标准方法。

## 属性查找：顺着链条往上

当访问一个对象的属性时（例如 `person1.species`），JavaScript 引擎会执行一个动态的查找过程，这被称为“原型链查找”：

1.  **实例优先**: 引擎首先检查对象实例自身是否拥有该属性（即“自有属性”或 "own property"）。如果找到，则返回其值，查找结束。
2.  **遍历链条**: 如果实例上没有找到，引擎会通过 `[[Prototype]]` 链接访问其原型对象，并在该对象上查找该属性。
3.  **继续向上**: 如果在原型对象上也未找到，查找过程会继续沿着原型对象的 `[[Prototype]]` 链接向上，逐级递归，直到 `Object.prototype`。
4.  **链条终点**: 如果在 `Object.prototype` 上也找不到，查找会到达原型链的终点（`Object.prototype.[[Prototype]]` 指向 `null`），此时引擎返回 `undefined`。

## 三种操作与它们的影响

对原型的操作可分为三类，其后果截然不同：

**修改原型对象**

这是向原型添加或修改属性的标准方法。

*   **语法**: `Person.prototype.sayHello = function() { /*...*/ };`
*   **机制**: 此操作直接在 `Person.prototype` 指向的那个共享对象上进行添加或修改。由于所有通过 `new Person()` 创建的实例的 `[[Prototype]]` 都引用了这同一个对象，所以变更会立即对所有实例生效（不论其创建于变更之前还是之后）。
*   **效果**: 全局共享。这是为类型扩展功能的推荐方式。

**实例赋值与属性遮蔽**

当对实例的继承属性进行赋值时，会发生属性遮蔽。

*   **语法**: `person1.species = "Alien";`
*   **机制**: 此赋值操作触发了 `[[Set]]` 内部方法。该方法首先检查 `person1` 自身。由于 `species` 不存在于 `person1` 的自有属性中，赋值操作会**在 `person1` 实例上创建一个新的自有属性** `species`。这个新属性会“遮蔽”或“隐藏”原型链上同名的 `species` 属性。
*   **效果**: 仅影响当前实例。`person2.species` 的访问路径不受影响，仍然会沿着原型链找到 `Person.prototype.species`。可以使用 `instance.hasOwnProperty('species')` 来验证属性是自有的还是继承的。

**重写整个 `prototype`**

这是一个破坏性操作，它用一个全新的对象替换了构造函数的 `prototype` 属性。

*   **语法**: `Person.prototype = { constructor: Person, sayHi: function() {} };`
*   **机制**: 此操作改变了 `Person.prototype` 的引用，使其指向一个全新的对象。这**切断了现有实例与新原型之间的联系**。
*   **效果**:
    *   **现有实例**: 在重写**之前**创建的实例，其 `[[Prototype]]` 仍然指向被废弃的**旧原型对象**。因此，它们无法访问新原型上的任何属性（如 `sayHi`）。
    *   **新实例**: 在重写**之后**创建的实例，其 `[[Prototype]]` 将指向这个**新原型对象**。
    *   **`constructor` 属性丢失**: 字面量对象 `{}` 的原型是 `Object.prototype`，它没有指向 `Person` 的 `constructor` 属性。因此，重写后必须显式地将 `constructor` 属性重新指回构造函数本身 (`constructor: Person`)，以维持原型链的完整性和 `instance.constructor` 的正确性。

## 现代方法与相关概念

**关于 `Object.create()`**

此方法提供了一种更直接的方式来设置对象的原型，它允许你创建一个新对象，并显式指定其 `[[Prototype]]`。
`const developer = Object.create(personPrototype);`
这使得我们可以实现原型继承，而无需依赖构造函数，是实现继承的更为纯粹的方式。

**关于 `class` 语法**

ES6 引入的 `class` 语法是 JavaScript 原型继承的**语法糖**。它提供了更清晰、更类似传统面向对象语言的语法，但其底层机制仍然是原型和原型链。

```javascript
class Person {
  constructor(name) { this.name = name; } // 自有属性
  sayHello() { console.log('Hello'); }   // 位于 Person.prototype
}
```

上述代码中的 `sayHello` 方法实际上被添加到了 `Person.prototype` 上，其行为与传统构造函数模式完全一致。理解原型是深入理解 `class` 工作原理的基础。