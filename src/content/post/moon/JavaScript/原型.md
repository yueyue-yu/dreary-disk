---
title: 原型
description: ""
publishDate:  2025-09-19
tags:
  - JavaScript
draft: false
---

好的，这是一个非常核心且重要的 JavaScript 概念。我们来详细拆解一下 `F.prototype` 和 `[[Prototype]]` 的区别与联系。

简单来说：

*   `F.prototype` 是一个**对象**，存在于**构造函数** `F` 上的一个普通属性。它的主要作用是让所有通过 `new F()` 创建出来的实例对象，都能共享它上面的属性和方法。
*   `[[Prototype]]` 是每个**对象**（包括函数）都拥有的一个**内部、隐藏的链接**，它指向另一个对象。这个链接构成了**原型链**，是 JavaScript 实现继承的根本机制。

下面我们来详细讲解。

---

## 1. `F.prototype` (函数的原型属性)

`F.prototype` 是一个只有**函数**才有的属性（严格来说，箭头函数没有）。当你声明一个函数时，JavaScript 会自动为这个函数创建一个 `prototype` 属性，它本身是一个普通的对象。

这个属性的核心用途是作为**新创建实例的原型**。

**它的特点：**

1.  **属于谁**：它属于**构造函数** `F`。你可以通过 `F.prototype` 直接访问它
2.  **是什么**：它是一个对象，可以像其他对象一样添加、修改、删除属性。
3.  **有什么用**：当你使用 `new F()` 创建一个新实例时，这个新实例的内部 `[[Prototype]]` 链接就会指向 `F.prototype`。

**代码示例：**

```javascript
// 1. 创建一个构造函数
function Dog(name) {
  this.name = name;
}

// 2. 在 Dog 函数的 prototype 对象上添加一个方法
//    这个方法将被所有 Dog 的实例共享
Dog.prototype.bark = function() {
  console.log('Woof! My name is ' + this.name);
};

// 3. 使用 new 关键字创建实例
const dog1 = new Dog('Buddy');
const dog2 = new Dog('Lucy');

// 4. 调用共享的方法
dog1.bark(); // 输出: Woof! My name is Buddy
dog2.bark(); // 输出: Woof! My name is Lucy

// 5. 验证两个实例共享同一个原型方法
console.log(dog1.bark === dog2.bark); // 输出: true

// 你可以直接查看 Dog.prototype 属性
console.log(Dog.prototype); // { bark: [Function (anonymous)], constructor: [Function: Dog] }
```

在这个例子中，`bark` 方法被定义在 `Dog.prototype` 上，而不是在每个实例（`dog1`, `dog2`）上。这样做的好处是**节省内存**，因为所有实例都引用了同一个函数，而不是每个实例都复制一份。

---

## 2. `[[Prototype]]` (对象的内部原型)

`[[Prototype]]` 是 JavaScript 引擎内部使用的一个属性，它存在于**每一个对象**上。它是一个指向其 " 父 " 对象（即原型对象）的链接。当你试图访问一个对象的某个属性时，如果该对象本身没有这个属性，JavaScript 引擎就会通过 `[[Prototype]]` 链接去它的原型对象上查找，如果还没有，就继续沿着原型对象的 `[[Prototype]]` 向上查找，直到找到属性或者到达原型链的终点 `null`。

**如何访问 `[[Prototype]]`?**

因为 `[[Prototype]]` 是一个内部属性，我们不能直接通过 `obj.[[Prototype]]` 来访问它。但有标准和非标准的方式可以做到：

1.  **`Object.getPrototypeOf(obj)`**: 这是 ES5 引入的**标准方法**，用于获取一个对象的 `[[Prototype]]`。
2.  **`obj.__proto__`**: 这是一个历史遗留的、非标准的访问器属性，虽然在大多数现代浏览器中都可用，但在生产代码中**不推荐使用**，主要用于学习和调试。

**代码示例（接上文）：**

```javascript
// ...继续使用上面的 Dog 例子

// 使用标准方法获取 dog1 的 [[Prototype]]
const protoOfDog1 = Object.getPrototypeOf(dog1);

// 验证 dog1 的 [[Prototype]] 是否就是 Dog 构造函数的 prototype 属性
console.log(protoOfDog1 === Dog.prototype); // 输出: true

// 使用非标准但直观的 __proto__ 属性
console.log(dog1.__proto__ === Dog.prototype); // 输出: true

// dog1 对象本身并没有 bark 方法
console.log(dog1.hasOwnProperty('bark')); // 输出: false

// bark 方法存在于 dog1 的原型上
console.log(protoOfDog1.hasOwnProperty('bark')); // 输出: true
```

这段代码的核心是 `Object.getPrototypeOf(dog1) === Dog.prototype`。它清晰地揭示了两者之间的关系：**通过 `new` 操作符创建的实例 `dog1`，它的内部 `[[Prototype]]` 链接被自动设置为其构造函数 `Dog` 的 `prototype` 属性。**

---

总结与对比

为了更清晰地理解，我们可以用一个表格来总结：

| 特性 | F.prototype | [[Prototype]] (或 `__proto__`) |
| :--- | :--- | :--- |
| **拥有者** | 构造函数 (`F`) | 每一个对象实例 (`obj`) |
| **本质** | 一个普通的 JavaScript 对象，是函数的一个属性 | 一个指向其他对象的内部链接（指针） |
| **作用** | 作为通过 `new F()` 创建的实例对象的**原型蓝图** | 构成**原型链**，为属性和方法的查找提供路径 |
| **访问方式** | `F.prototype` | `Object.getPrototypeOf(obj)` 或 `obj.__proto__` |
| **关系** | 当执行 `const obj = new F()` 时，`obj` 的 `[[Prototype]]` 会被设置为 `F.prototype` |

**核心关系图：**

```
           +-----------------+
           |  Constructor F  |
           +-----------------+
                   | .prototype
                   v
+------------------+-------------------+
|               F.prototype            |  <-- obj.[[Prototype]] 指向这里
| (An Object)                        |
| - constructor: F                   |
| - sharedMethod: function() {...}   |
+------------------------------------+
                   ^
                   | new F() 创建时建立的链接
                   |
+------------------+
|      obj         |
| (An instance)    |
| - ownProperty    |
+------------------+
```

搞清楚 `F.prototype` 和 `[[Prototype]]` 是理解 JavaScript 面向对象编程、继承和原型链的关键。




## 函数的 prototype 属性

“几乎所有用 `function` 关键字声明的普通函数，在创建时都会自动获得一个 `prototype` 属性”**。

这也就意味着，任何一个普通函数都**有潜力**成为一个构造函数，只要你用 `new` 关键字去调用它。

而有一个重要的例外：**箭头函数 (`=>`) 是没有 `prototype` 属性的。**

---

### 详细解释

#### 1. 普通函数 (Function Declarations & Expressions)

当你用 `function` 关键字定义一个函数时，无论你的本意是不是要用它作构造函数，JavaScript 引擎都会自动为它创建一个 `prototype` 属性。这个 `prototype` 是一个对象，它包含一个 `constructor` 属性，指回函数本身。

**示例：一个“普通”的函数**

```javascript
// 我只是想定义一个打印消息的函数，没想过要 new 它
function greet(message) {
  console.log(message);
}

// 即使如此，它仍然有 prototype 属性
console.log(typeof greet.prototype); // 输出: "object"

// 它的 prototype 对象上默认有一个 constructor 属性，指向它自己
console.log(greet.prototype.constructor === greet); // 输出: true

// 因为它有 prototype，所以我们 *可以* 把它当作构造函数使用（尽管没什么意义）
const instance = new greet('hello'); // 'hello' 会被打印出来
console.log(instance); // 输出: greet {} (一个空的对象，其 [[Prototype]] 指向 greet.prototype)
```

**结论：** 一个函数是不是“构造函数”，并不取决于它如何定义，而在于它如何**被调用**。只要一个函数有 `prototype` 属性，它就可以通过 `new` 调用来充当构造函数。

#### 2. 箭头函数 (Arrow Functions)

箭头函数是 ES6 引入的一个重要特性，它的设计初衷就是作为“非构造函数”使用。因此，**箭头函数没有自己的 `prototype` 属性**。

如果你试图用 `new` 关键字调用一个箭头函数，程序会直接抛出一个错误。

**示例：箭头函数**

```javascript
const add = (a, b) => a + b;

// 箭头函数没有 prototype 属性
console.log(add.prototype); // 输出: undefined

// 尝试 new 一个箭头函数会报错
try {
  const result = new add(1, 2);
} catch (e) {
  console.error(e); // 输出: TypeError: add is not a constructor
}
```

箭头函数的设计目标是：
* 更简洁的语法。
* 词法绑定的 `this`（`this` 的值由外层作用域决定，而不是由调用方式决定）。
* 它们不能作为构造函数，也没有 `arguments` 对象。

---

### 总结

| 函数类型 | 如何定义 | 是否有 `.prototype` 属性? | 是否能用 `new` 调用? |
| :--- | :--- | :--- | :--- |
| **函数声明** | `function myFunction() {}` | **有** | **是** |
| **函数表达式** | `const myFunc = function() {};` | **有** | **是** |
| **箭头函数** | `const myArrow = () => {};` | **没有** | **否** (会抛出 `TypeError`) |
| **类 (Class)** | `class MyClass {}` | **有**¹ | **是** (必须用 `new`) |

¹ `class` 语法是 JavaScript 中函数和原型的语法糖。`MyClass` 本身实际上是一个函数，它的 `prototype` 属性就是给实例用的。

所以，更精确的说法是：**所有用 `function` 关键字创建的函数都有 `prototype` 属性，而箭头函数没有。** 一个函数是否扮演“构造函数”的角色，取决于它是否与 `new` 操作符一起被使用。



## class 语法

`class` 语法本质上就是 `F.prototype` 模式的“语法糖” (Syntactic Sugar)。**

这意味着，`class` 并没有引入新的底层机制，它只是用一种更清晰、更结构化、更符合传统面向对象编程思想的语法，来包装和简化了原本基于 `prototype` 的操作。

---

### 最直观的对比：代码如何等价转换

让我们用一个例子来展示 `class` 是如何被“翻译”成 `prototype` 写法的。

#### 1. 定义一个类和方法

**现代 `class` 写法 (您正在用的):**

```javascript
class Cat {
  // constructor 负责创建实例属性
  constructor(name, color) {
    this.name = name;
    this.color = color;
  }

  // 所有在 class 中直接定义的方法，都是实例共享的
  meow() {
    console.log(`Meow! I am ${this.name}.`);
  }

  // 静态方法，属于类本身，不属于实例
  static sayHello() {
    console.log('Hello from the Cat class!');
  }
}

const kitty = new Cat('Kitty', 'white');
kitty.meow(); // "Meow! I am Kitty."
Cat.sayHello(); // "Hello from the Cat class!"
```

**等价的 `F.prototype` 写法 (背后发生的事):**

```javascript
// Cat class 本质上就是一个构造函数
function Cat(name, color) {
  // class 内部默认是严格模式 'use strict';

  // class 的 constructor 内容就是这个函数体
  this.name = name;
  this.color = color;
}

// class 中定义的实例方法，被添加到了构造函数的 prototype 对象上
Cat.prototype.meow = function() {
  console.log(`Meow! I am ${this.name}.`);
};

// class 的静态方法，被直接添加到了构造函数这个对象上
Cat.sayHello = function() {
  console.log('Hello from the Cat class!');
};

const kitty = new Cat('Kitty', 'white');
kitty.meow(); // "Meow! I am Kitty."
Cat.sayHello(); // "Hello from the Cat class!"
```

通过这个对比，联系就非常清晰了：

*   **`class Cat {...}`** 对应 **`function Cat(...) {...}`**
*   **`constructor(...)`** 对应 **构造函数 `Cat` 的函数体**
*   **`meow() {}` (实例方法)** 对应 **`Cat.prototype.meow = function() {}`**
*   **`static sayHello() {}` (静态方法)** 对应 **`Cat.sayHello = function() {}`**

#### 2. 实现继承 (extends 和 super)

`class` 语法的最大便利之一就是简化了继承。

**现代 `class` 继承写法:**

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name); // 调用父类的 constructor
    this.breed = breed;
  }
  speak() {
    console.log(`${this.name} barks.`);
  }
}

const dog = new Dog('Rex', 'German Shepherd');
dog.speak(); // "Rex barks."
```

**等价的 `F.prototype` 继承写法 (复杂得多):**

```javascript
function Animal(name) {
  this.name = name;
}
Animal.prototype.speak = function() {
  console.log(`${this.name} makes a noise.`);
};

function Dog(name, breed) {
  // 1. 调用父类构造函数，继承实例属性 (等价于 super(name))
  Animal.call(this, name); 
  this.breed = breed;
}

// 2. 继承父类的原型方法
// 让 Dog.prototype 的 [[Prototype]] 指向 Animal.prototype
Object.setPrototypeOf(Dog.prototype, Animal.prototype);

// 如果不用 setPrototypeOf，传统的做法更复杂：
// Dog.prototype = Object.create(Animal.prototype);
// Dog.prototype.constructor = Dog; // 修复 constructor 指向

// 3. 定义子类自己的方法（必须在继承之后）
Dog.prototype.speak = function() {
  console.log(`${this.name} barks.`);
};

const dog = new Dog('Rex', 'German Shepherd');
dog.speak(); // "Rex barks."
```

可以看到，`extends` 和 `super` 两个关键字，帮我们自动完成了背后复杂的原型链关联和父类构造函数的调用。


